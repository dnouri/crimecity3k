"""Shared pytest fixtures for CrimeCity3K tests."""

import multiprocessing
import socket
import time
from collections.abc import Generator
from pathlib import Path

import duckdb
import pytest

from crimecity3k.config import Config


def _find_free_port() -> int:
    """Find an available port for the test server."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(("", 0))
        s.listen(1)
        port: int = s.getsockname()[1]
        return port


def _run_server(port: int, root_dir: Path) -> None:
    """Run FastAPI server in subprocess.

    This server supports HTTP Range requests (via Starlette's StaticFiles),
    which PMTiles requires.
    """
    import uvicorn

    from crimecity3k.api.main import create_app

    app = create_app(root_dir)
    uvicorn.run(app, host="127.0.0.1", port=port, log_level="warning")


@pytest.fixture(scope="module")
def live_server() -> Generator[str]:
    """Start a static file server for E2E tests.

    Uses Starlette's StaticFiles which supports HTTP Range requests,
    required for PMTiles to function properly.

    Serves PMTiles from tests/fixtures/pmtiles/ directory, which are
    generated by `make test-fixtures` before running E2E tests.

    Yields:
        Server URL (e.g., "http://localhost:8080")
    """
    port = _find_free_port()
    server_url = f"http://127.0.0.1:{port}"
    # Use tests/fixtures/ as server root (contains static/, data/events.parquet, etc.)
    project_root = Path(__file__).parent / "fixtures"

    # Start server in subprocess (uvicorn needs its own process)
    server_process = multiprocessing.Process(target=_run_server, args=(port, project_root))
    server_process.start()

    # Wait for server to be ready (including database initialization)
    import requests  # type: ignore[import-untyped]

    for _ in range(60):  # Up to 6 seconds for DB init
        # Check if server process crashed during startup
        if not server_process.is_alive():
            server_process.join(timeout=1)
            pytest.fail(
                f"Test server crashed during startup (exit code: {server_process.exitcode})"
            )
        try:
            response = requests.get(f"{server_url}/health", timeout=1)
            if response.status_code == 200:
                break
        except (requests.ConnectionError, requests.Timeout):
            time.sleep(0.1)
    else:
        # Loop completed without successful health check
        if server_process.is_alive():
            server_process.terminate()
        server_process.join(timeout=5)
        pytest.fail(f"Test server failed to respond within timeout on {server_url}")

    yield server_url

    # Cleanup
    server_process.terminate()
    server_process.join(timeout=5)


@pytest.fixture
def test_config() -> Config:
    """Create test configuration with safe defaults.

    Returns:
        Config object with test-specific settings
    """
    config = Config()
    # Override for tests
    config.aggregation.resolutions = [5]
    config.duckdb.memory_limit = "1GB"
    config.duckdb.threads = 1
    config.duckdb.temp_directory = "/tmp/test_duckdb"
    return config


@pytest.fixture
def duckdb_conn(
    test_config: Config,
) -> Generator[duckdb.DuckDBPyConnection]:
    """In-memory DuckDB with h3 and spatial extensions.

    Following aviation-anomaly pattern for reliable extension loading in CI.

    Args:
        test_config: Test configuration fixture

    Yields:
        Configured DuckDB connection

    Note:
        Connection is automatically closed after test
    """
    conn = duckdb.connect(":memory:")

    # Apply basic DuckDB settings
    conn.execute(f"SET memory_limit = '{test_config.duckdb.memory_limit}'")
    conn.execute(f"SET threads = {test_config.duckdb.threads}")

    # Install and load spatial extension (core extension)
    try:
        conn.execute("INSTALL spatial")
        conn.execute("LOAD spatial")
    except Exception as e:
        pytest.skip(f"Spatial extension not available: {e}")

    # Install and load H3 extension from community repository
    try:
        conn.execute("INSTALL h3 FROM community")
        conn.execute("LOAD h3")
    except Exception as e:
        pytest.fail(f"H3 extension is required but failed to load: {e}")

    yield conn
    conn.close()


@pytest.fixture
def sample_events(duckdb_conn: duckdb.DuckDBPyConnection) -> duckdb.DuckDBPyConnection:
    """Load test fixture events into DuckDB.

    Args:
        duckdb_conn: DuckDB connection fixture

    Returns:
        DuckDB connection with 'events' table loaded
    """
    fixture_path = Path(__file__).parent / "fixtures" / "data" / "events.parquet"
    duckdb_conn.execute(f"""
        CREATE TABLE events AS
        SELECT * FROM '{fixture_path}'
    """)
    return duckdb_conn


@pytest.fixture
def synthetic_population_h3(tmp_path: Path, duckdb_conn: duckdb.DuckDBPyConnection) -> Path:
    """Create synthetic population data for H3 cells in test fixture.

    Creates a minimal population dataset with 1000 people per H3 cell,
    covering all cells in the events test fixture.

    Args:
        tmp_path: Pytest temporary directory fixture
        duckdb_conn: DuckDB connection with H3 extension

    Returns:
        Path to synthetic population Parquet file
    """
    fixture_path = Path(__file__).parent / "fixtures" / "data" / "events.parquet"
    population_path = tmp_path / "synthetic_population_r5.parquet"

    duckdb_conn.execute(f"""
        COPY (
            WITH h3_cells AS (
                SELECT DISTINCT h3_latlng_to_cell_string(latitude, longitude, 5) as h3_cell
                FROM '{fixture_path}'
            )
            SELECT
                h3_cell,
                1000.0 as population
            FROM h3_cells
        ) TO '{population_path}' (FORMAT PARQUET)
    """)

    return population_path
